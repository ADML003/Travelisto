Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const api = require('@opentelemetry/api');
const core$1 = require('@opentelemetry/core');
const semanticConventions = require('@opentelemetry/semantic-conventions');
const core = require('@sentry/core');
const stream = require('stream');

/**
 * Wraps the original handleRequest function to add Sentry instrumentation.
 *
 * @param originalHandle - The original handleRequest function to wrap
 * @returns A wrapped version of the handle request function with Sentry instrumentation
 */
function wrapSentryHandleRequest(originalHandle) {
  return async function sentryInstrumentedHandleRequest(
    request,
    responseStatusCode,
    responseHeaders,
    routerContext,
    loadContext,
  ) {
    const parameterizedPath =
      routerContext?.staticHandlerContext?.matches?.[routerContext.staticHandlerContext.matches.length - 1]?.route.path;
    if (parameterizedPath) {
      const activeSpan = core.getActiveSpan();
      if (activeSpan) {
        const rootSpan = core.getRootSpan(activeSpan);
        const routeName = `/${parameterizedPath}`;

        // The express instrumentation writes on the rpcMetadata and that ends up stomping on the `http.route` attribute.
        const rpcMetadata = core$1.getRPCMetadata(api.context.active());
        if (rpcMetadata?.type === core$1.RPCType.HTTP) {
          rpcMetadata.route = routeName;
        }

        // The span exporter picks up the `http.route` (ATTR_HTTP_ROUTE) attribute to set the transaction name
        rootSpan.setAttributes({
          [semanticConventions.ATTR_HTTP_ROUTE]: routeName,
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
        });
      }
    }

    return originalHandle(request, responseStatusCode, responseHeaders, routerContext, loadContext);
  };
}

/** @deprecated Use `wrapSentryHandleRequest` instead. */
const sentryHandleRequest = wrapSentryHandleRequest;

/**
 * Injects Sentry trace meta tags into the HTML response by piping through a transform stream.
 * This enables distributed tracing by adding trace context to the HTML document head.
 *
 * @param body - PassThrough stream containing the HTML response body to modify
 */
function getMetaTagTransformer(body) {
  const headClosingTag = '</head>';
  const htmlMetaTagTransformer = new stream.Transform({
    transform(chunk, _encoding, callback) {
      const html = Buffer.isBuffer(chunk) ? chunk.toString() : String(chunk);
      if (html.includes(headClosingTag)) {
        const modifiedHtml = html.replace(headClosingTag, `${core.getTraceMetaTags()}${headClosingTag}`);
        callback(null, modifiedHtml);
        return;
      }
      callback(null, chunk);
    },
  });
  htmlMetaTagTransformer.pipe(body);
  return htmlMetaTagTransformer;
}

exports.getMetaTagTransformer = getMetaTagTransformer;
exports.sentryHandleRequest = sentryHandleRequest;
exports.wrapSentryHandleRequest = wrapSentryHandleRequest;
//# sourceMappingURL=wrapSentryHandleRequest.js.map
