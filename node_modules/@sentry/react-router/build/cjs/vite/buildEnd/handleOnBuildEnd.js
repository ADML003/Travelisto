Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const promises = require('node:fs/promises');
const SentryCli = require('@sentry/cli');
const glob = require('glob');

function getSentryConfig(viteConfig) {
  if (!viteConfig || typeof viteConfig !== 'object' || !('sentryConfig' in viteConfig)) {
    // eslint-disable-next-line no-console
    console.error('[Sentry] sentryConfig not found - it needs to be passed to vite.config.ts');
  }

  return (viteConfig ).sentryConfig;
}

/**
 * A build end hook that handles Sentry release creation and source map uploads.
 * It creates a new Sentry release if configured, uploads source maps to Sentry,
 * and optionally deletes the source map files after upload.
 */
const sentryOnBuildEnd = async ({ reactRouterConfig, viteConfig }) => {
  const {
    authToken,
    org,
    project,
    release,
    sourceMapsUploadOptions = { enabled: true },
    debug = false,
    unstable_sentryVitePluginOptions,
  } = getSentryConfig(viteConfig);

  const cliInstance = new SentryCli.default(null, {
    authToken,
    org,
    project,
    ...unstable_sentryVitePluginOptions,
  });
  // check if release should be created
  if (release?.name) {
    try {
      await cliInstance.releases.new(release.name);
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('[Sentry] Could not create release', error);
    }
  }

  if (sourceMapsUploadOptions?.enabled ?? (viteConfig.build.sourcemap !== false)) {
    // inject debugIds
    try {
      await cliInstance.execute(['sourcemaps', 'inject', reactRouterConfig.buildDirectory], debug);
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('[Sentry] Could not inject debug ids', error);
    }

    // upload sourcemaps
    try {
      await cliInstance.releases.uploadSourceMaps(release?.name || 'undefined', {
        include: [
          {
            paths: [reactRouterConfig.buildDirectory],
          },
        ],
      });
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('[Sentry] Could not upload sourcemaps', error);
    }
  }
  // delete sourcemaps after upload
  let updatedFilesToDeleteAfterUpload = sourceMapsUploadOptions?.filesToDeleteAfterUpload;
  // set a default value no option was set
  if (typeof sourceMapsUploadOptions?.filesToDeleteAfterUpload === 'undefined') {
    updatedFilesToDeleteAfterUpload = [`${reactRouterConfig.buildDirectory}/**/*.map`];
    if (debug) {
      // eslint-disable-next-line no-console
      console.info(
        `[Sentry] Automatically setting \`sourceMapsUploadOptions.filesToDeleteAfterUpload: ${JSON.stringify(
          updatedFilesToDeleteAfterUpload,
        )}\` to delete generated source maps after they were uploaded to Sentry.`,
      );
    }
  }
  if (updatedFilesToDeleteAfterUpload) {
    try {
      const filePathsToDelete = await glob.glob(updatedFilesToDeleteAfterUpload, {
        absolute: true,
        nodir: true,
      });
      if (debug) {
        filePathsToDelete.forEach(filePathToDelete => {
          // eslint-disable-next-line no-console
          console.info(`Deleting asset after upload: ${filePathToDelete}`);
        });
      }
      await Promise.all(
        filePathsToDelete.map(filePathToDelete =>
          promises.rm(filePathToDelete, { force: true }).catch((e) => {
            if (debug) {
              // This is allowed to fail - we just don't do anything
              // eslint-disable-next-line no-console
              console.debug(`An error occurred while attempting to delete asset: ${filePathToDelete}`, e);
            }
          }),
        ),
      );
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Error deleting files after sourcemap upload:', error);
    }
  }
};

exports.sentryOnBuildEnd = sentryOnBuildEnd;
//# sourceMappingURL=handleOnBuildEnd.js.map
